/**
 * Project      graduation-cap-leds
 * @file        micro_LED.ino
 * @author      Sean Duffie
 * @link        https://github.com/SeanDuffie/graduation-cap-leds
 * 
 * The purpose of this project is to create a 
 */

#include "FastLED.h"
// #include <FastLED_NeoPixel.h>

// Which pin on the Arduino is connected to the LEDs?
#define DATA_PIN 3
#define COLOR_ORDER GRB
#define CHIPSET     WS2812B

// LED brightness, 0 (min) to 255 (max)
#define BRIGHTNESS 100

// Amount of time for each half-blink, in milliseconds
#define BLINK_TIME 100

// How many LEDs are attached to the Arduino?
const uint8_t WIDTH = 16;
const uint8_t LENGTH = 16;
#define NUM_LEDS (WIDTH * LENGTH)
// const uint8_t LAST_VISIBLE_LED = NUM_LEDS-1;

// Param for different pixel layouts
const bool    kMatrixSerpentineLayout = true;
const bool    kMatrixVertical = false;

/* Declare the NeoPixel strip object:
*     * Argument 1 = Number of LEDs in the LED strip
*     * Argument 2 = Arduino pin number
*     * Argument 3 = LED strip color order
* 
* The FastLED_NeoPixel version uses template arguments instead of function
* arguments. Note the use of '<>' brackets!
* 
* You can switch between libraries by commenting out one of these two objects.
* In this example they should behave identically.
*/
// Adafruit_NeoPixel strip(NUM_LEDS, DATA_PIN, NEO_GRB);  // <- Adafruit NeoPixel version
// FastLED_NeoPixel<NUM_LEDS, DATA_PIN, NEO_GRB> strip;      // <- FastLED NeoPixel version

CRGB leds_plus_safety_pixel[ NUM_LEDS + 1];
CRGB* const leds( leds_plus_safety_pixel + 1);

/** Helper functions for an two-dimensional XY matrix of pixels.
    Simple 2-D demo code is included as well.

        XY(x,y) takes x and y coordinates and returns an LED index number,
                for use like this:  leds[ XY(x,y) ] == CRGB::Red;
                No error checking is performed on the ranges of x and y.

        XYsafe(x,y) takes x and y coordinates and returns an LED index number,
                for use like this:  leds[ XYsafe(x,y) ] == CRGB::Red;
                Error checking IS performed on the ranges of x and y, and an
                index of "-1" is returned.  Special instructions below
                explain how to use this without having to do your own error
                checking every time you use this function.  
                This is a slightly more advanced technique, and 
                it REQUIRES SPECIAL ADDITIONAL setup, described below.
 */

/** Set 'kMatrixSerpentineLayout' to false if your pixels are 
    laid out all running the same way, like this:

    0 >  1 >  2 >  3 >  4
                        |
    .----<----<----<----'
    |
    5 >  6 >  7 >  8 >  9
                        |
    .----<----<----<----'
    |
    10 > 11 > 12 > 13 > 14
                        |
    .----<----<----<----'
    |
    15 > 16 > 17 > 18 > 19

    Set 'kMatrixSerpentineLayout' to true if your pixels are 
    laid out back-and-forth, like this:

    0 >  1 >  2 >  3 >  4
                        |
                        |
    9 <  8 <  7 <  6 <  5
    |
    |
    10 > 11 > 12 > 13 > 14
                        |
                        |
    19 < 18 < 17 < 16 < 15

    Bonus vocabulary word: anything that goes one way 
    in one row, and then backwards in the next row, and so on
    is call "boustrophedon", meaning "as the ox plows."


    This function will return the right 'led index number' for 
    a given set of X and Y coordinates on your matrix.  
    IT DOES NOT CHECK THE COORDINATE BOUNDARIES.  
    That's up to you.  Don't pass it bogus values.

    Use the "XY" function like this:

    for( uint8_t x = 0; x < kMatrixWidth; x++) {
        for( uint8_t y = 0; y < kMatrixHeight; y++) {
        
        // Here's the x, y to 'led index' in action: 
        leds[ XY( x, y) ] = CHSV( random8(), 255, 255);
        
        }
    }
 */
uint16_t XY( uint8_t x, uint8_t y)
{
  uint16_t i;
  
  if( kMatrixSerpentineLayout == false) {
    if (kMatrixVertical == false) {
      i = (y * WIDTH) + x;
    } else {
      i = LENGTH * (WIDTH - (x+1))+y;
    }
  }

  if( kMatrixSerpentineLayout == true) {
    if (kMatrixVertical == false) {
      if( y & 0x01) {
        // Odd rows run backwards
        uint8_t reverseX = (WIDTH - 1) - x;
        i = (y * WIDTH) + reverseX;
      } else {
        // Even rows run forwards
        i = (y * WIDTH) + x;
      }
    } else { // vertical positioning
      if ( x & 0x01) {
        i = LENGTH * (WIDTH - (x+1))+y;
      } else {
        i = LENGTH * (WIDTH - x) - (y+1);
      }
    }
  }
  
  return i;
}

/** Once you've gotten the basics working (AND NOT UNTIL THEN!)
    here's a helpful technique that can be tricky to set up, but 
    then helps you avoid the needs for sprinkling array-bound-checking
    throughout your code.

    It requires a careful attention to get it set up correctly, but
    can potentially make your code smaller and faster.

    Suppose you have an 8 x 5 matrix of 40 LEDs.  Normally, you'd
    delcare your leds array like this:
    CRGB leds[40];
    But instead of that, declare an LED buffer with one extra pixel in
    it, "leds_plus_safety_pixel".  Then declare "leds" as a pointer to
    that array, but starting with the 2nd element (id=1) of that array: 
    CRGB leds_with_safety_pixel[41];
    CRGB* const leds( leds_plus_safety_pixel + 1);
    Then you use the "leds" array as you normally would.
    Now "leds[0..N]" are aliases for "leds_plus_safety_pixel[1..(N+1)]",
    AND leds[-1] is now a legitimate and safe alias for leds_plus_safety_pixel[0].
    leds_plus_safety_pixel[0] aka leds[-1] is now your "safety pixel".

    Now instead of using the XY function above, use the one below, "XYsafe".

    If the X and Y values are 'in bounds', this function will return an index
    into the visible led array, same as "XY" does.
    HOWEVER -- and this is the trick -- if the X or Y values
    are out of bounds, this function will return an index of -1.
    And since leds[-1] is actually just an alias for leds_plus_safety_pixel[0],
    it's a totally safe and legal place to access.  And since the 'safety pixel'
    falls 'outside' the visible part of the LED array, anything you write 
    there is hidden from view automatically.
    Thus, this line of code is totally safe, regardless of the actual size of
    your matrix:
    leds[ XYsafe( random8(), random8() ) ] = CHSV( random8(), 255, 255);

    The only catch here is that while this makes it safe to read from and
    write to 'any pixel', there's really only ONE 'safety pixel'.  No matter
    what out-of-bounds coordinates you write to, you'll really be writing to
    that one safety pixel.  And if you try to READ from the safety pixel,
    you'll read whatever was written there last, reglardless of what coordinates
    were supplied.
 */
uint16_t XYsafe( uint8_t x, uint8_t y)
{
  if( x >= WIDTH) return -1;
  if( y >= LENGTH) return -1;
  return XY(x,y);
}

int c = 0;

/*********** IMAGE LIB **********/
const long Doge[] PROGMEM =
{
0x000000,0x000000,0x000000,0x000000,0x000000,0x000000,0x000000,0x000000,0x000000,0x000000,0x000000,0x000000,0x000000,0x000000,0x000000,
0x000000,0x000000,0x000000,0x000000,0x000000,0x000000,0x4c3318,0x000000,0x000000,0x000000,0x000000,0x6a6045,0x946729,0x010101,0x000000,
0x000000,0x000000,0x000000,0x000000,0x000000,0x020005,0xbc7c30,0x705d33,0x000308,0x000105,0x54492b,0xa87f42,0x8e5e34,0x000004,0x000000,
0x000000,0x000000,0x000000,0x000102,0x020004,0xdab775,0xc69c50,0xbd8435,0xcca152,0xc68f45,0x925625,0x936f3d,0x8e6a3e,0x030001,0x000000,
0x000000,0x000000,0x000000,0xeabc81,0xe3b775,0xd5b676,0xbb9045,0xc59f60,0xbba569,0xc29a4e,0xca964a,0x4d2117,0x94692f,0x000101,0x000000,
0x000000,0x000000,0x000000,0xf5e8c6,0x5d4d3b,0xc09e5b,0xc8a35c,0xc1a573,0x91785a,0xbe9247,0xcba55c,0xd3a65c,0x884a11,0xcead73,0x000000,
0x000000,0x000000,0x000102,0xe8dfb9,0xdec17d,0xe4bb78,0xd3a961,0x3f270b,0x1b120d,0xccb371,0xcdb172,0xcaa868,0xc89742,0xc99e5d,0x000000,
0x000000,0x000000,0x777152,0x88897b,0x1b1a16,0x6d674b,0xdcbd84,0xd7b979,0xc6a564,0xcbbb8d,0xd6c59a,0xd3be8f,0xcead69,0xcea355,0x000000,
0x000000,0x000000,0xdbd0a1,0x767364,0x1e1d1b,0x8a8873,0xcdbf90,0xcfbd8d,0xc6b78e,0xccbf95,0xccb788,0xc0a973,0xbd9852,0xc5994e,0x050307,
0x000000,0x000000,0xe5d7a7,0x9e966e,0x1c1914,0x7f795f,0xb39c68,0xa99162,0xbda873,0xccb784,0xc6b27f,0xc5b17d,0xb68f46,0xbb9243,0xcfb488,
0x000000,0x000000,0xa09b77,0xd5be88,0x846c3f,0xa18e63,0xa28851,0xc7aa70,0xbb9e64,0xc2ad7e,0xc0a973,0xbf9c55,0xc09043,0xae792d,0xc69c58,
0x000000,0x000000,0xaea07a,0xd5b680,0xcdb27a,0xc8aa6e,0xb89b60,0xbc9e62,0xc5ab78,0xc2b17d,0xbca36a,0xbf9549,0xa96f2a,0xb47f39,0xca9f54,
0x000000,0x000000,0xdbc389,0xdaba74,0xc6a763,0xc4a564,0xbe9e5e,0xb89a5a,0xb39856,0xb69a61,0xb3985f,0xc19b4e,0xbf9148,0xcaac69,0xcbb172,
0x000000,0x000000,0xe8d198,0xd9bf87,0xc9aa73,0xb59250,0xb3904d,0xae9457,0xc0ab79,0xc7ac77,0xcbb178,0xcab581,0xccb782,0xc3b37f,0xcca967,
0x000000,0x000000,0xa4925c,0xd6bf8c,0xc7aa70,0xb09053,0xbc9c5f,0xbea874,0xbca772,0xc6b17b,0xd4c08b,0xcab98b,0xcbb98b,0xc7b380,0xc39850,
0x000105,0xebc074,0xe9d39b,0xd7bb7c,0xc6a96a,0xbfa060,0xc2a56d,0xb9a46d,0xc8b37e,0xc9b682,0xc8b387,0xcdb987,0xcdb885,0xcfaa6b,0xb88237
};

const long Arthur[] PROGMEM =
{
0xe2ca06,0xe4c707,0xe3c805,0xe5c906,0xe8c80b,0xe2ca06,0xe2ca06,0xe6cb08,0xe4c906,0xe5c904,0xe3cb07,0xe7cb06,0x9e821d,0xe3c517,0xe9c60a,
0xe1cb06,0xe6cb08,0xe4c906,0xe2ca06,0xe1c80b,0xe2c50f,0xe0cc09,0xdecb0f,0xe2cc17,0xe3c702,0xe5ca0b,0xe0cc0b,0xe1cc00,0xe2cc07,0xe2ca06,
0xe1cb06,0xe1cb06,0xe1cb06,0xe1ca0b,0xbca113,0xa48919,0xe6c90d,0xe9c906,0xe8cd08,0xe2cb1b,0xdfc611,0xcdae43,0xe1ce08,0xdfcc07,0xe1c80c,
0xe2ca06,0xe4cb0f,0xe5c737,0xe1cd0e,0xe3cd08,0xdcc610,0xe1c905,0xe2cc07,0xdecd04,0x947606,0xe2cb0d,0xbaa029,0xa5a84e,0x819c91,0x739aab,
0xe2ca06,0xdcc424,0xdeca30,0xe1cb0a,0xe1cb06,0xe2cb09,0xe8ce44,0x90691f,0xc09d4c,0xb79359,0xb69955,0x3f3c17,0x6e9daf,0x6d9cac,0x6e9dad,
0xe6cb09,0xe1ca2f,0xe0c60a,0xe2ce0b,0xc1a42e,0xb79450,0xba9455,0xbd954f,0xbf974f,0xbd9647,0xbc964c,0xbc9548,0xb28f50,0x889caa,0x6ca0ad,
0x724316,0x9f8b2b,0xe5ca05,0xae9141,0xbc9751,0xbb9449,0xbe944a,0xbd964b,0xbd964b,0xbd964b,0xbd964b,0xbc954a,0xbd964b,0xbb9447,0x556967,
0x9e685d,0xb6bad5,0xd8c24e,0xb79452,0xbb954e,0xbd964b,0xbc964a,0xbf954a,0xbe974c,0xbd964a,0xbd964b,0xbd964a,0xbd964b,0xbd964a,0xaf8756,
0x794135,0x52596c,0x678c9e,0xbe9054,0xbb954c,0xba954d,0xb9944d,0xbc944e,0xbf954d,0xbb954c,0xbd9649,0xbb954c,0xbb9449,0xbd954d,0xbc8f54,
0x563211,0xf7f0f7,0x607e9a,0xb79556,0xbb954c,0xbb954e,0xb8964e,0xba954c,0xbb964d,0xbd964b,0xbd964b,0xbc944e,0xb9924d,0xa07e52,0xbb9743,
0xac6271,0xaa5a6d,0x8191a9,0xaa9e59,0xbb954e,0xbb954c,0xba954e,0xbb944d,0xbb954c,0xbc944e,0xbf984d,0xbe944b,0xb48e47,0xa78758,0xbb974d,
0x173d38,0x1b3937,0x759fb2,0x5d6461,0xba954e,0xb8964f,0xb8964e,0xb8964e,0xbb974d,0xbb954e,0xb79450,0xbc954a,0xbb9449,0xba964f,0xbd9261,
0x0e473b,0x104943,0x7195a7,0x2e5954,0xbb954c,0xb8964f,0xba9850,0xb6964d,0xba964c,0xba964c,0xbc9656,0xb3924b,0xbd964b,0xbb944c,0x372a07,
0x11443f,0x0f4640,0x709daf,0x547886,0xb9a260,0xba954c,0xbb9951,0xb8964c,0xb7954b,0xb5974e,0xb99450,0x684914,0xb89447,0xae9766,0x6d9aae,
0x0e4740,0x154f43,0x2d4e58,0x6e9cab,0x7798a7,0xb79a4e,0xb8934c,0xb8964e,0xbd924d,0x6b430f,0xb49760,0x39432c,0x749fb0,0x739eae,0x6e9dad,
0x7e5a66,0x645467,0x564f5f,0x7a97ac,0x6f9eae,0x6c929b,0xa99472,0xb08b4f,0x57401d,0x5c5f6a,0x6f9cb3,0x6d9cac,0x6d9ead,0x6f9eae,0x6d9ead
};

const long Patrick[] PROGMEM =
{
0x32181c,0x281c20,0x231e20,0x211b1c,0xeaeae9,0xeeeeee,0xefefef,0xffffff,0xfefefe,0xfefefe,0xefefef,0xececec,0xe8e8e8,0xeaeaea,0xfefefe,
0x281c1f,0xfc7fa8,0xfb7fb1,0xe775a1,0xeb75a7,0x27141d,0xe9ece9,0xfdfdfd,0xfdfdfd,0xfdfdfd,0xeeeeee,0xebebeb,0xe9e9e9,0xeaeaea,0xfcfcfc,
0xfdfdfd,0xfb81a9,0xfd7eb1,0xed74a5,0xed73a7,0xf275a7,0xf077a8,0x320a1a,0x181c1a,0xfdfdfd,0xeeeeee,0xebebeb,0xe8e8e8,0xe9e9e9,0xfcfcfc,
0xe9e9e9,0xebeae9,0xec74a6,0xdc6897,0x840f1f,0xe06b9f,0xdf6c98,0xe974a5,0xec73a4,0xdf7ba2,0x1b1a1a,0xc0c5c1,0xd3d7d6,0xd7d7d7,0xe9e9e9,
0xeaeaea,0xe6e9e8,0xe6e6e6,0x734354,0xda6a96,0xdd6c99,0x1f0e15,0x221a17,0xec73a4,0xee73a5,0xde6b98,0xaf5d7d,0x504c4a,0xd7d8d7,0xe9e9e9,
0xefefef,0xeeeeee,0xefeeef,0xd1d9d7,0xdc6e9d,0xe76d9e,0xb66383,0xe87ea9,0x4a2a36,0xc4c8c5,0x6a2b45,0xde6f9c,0xdb6e9b,0xbe5f85,0x424340,
0xefefef,0xeeeeee,0xededed,0xdadcdb,0x6e6b6b,0x200f17,0xe06f9d,0x24121a,0xeeeeee,0xefefef,0xd0d2c7,0x20151f,0xde6c98,0xdf6b9a,0xe480a7,
0xfefefe,0xfefefe,0xfdfdfd,0xe9e9e9,0xeaeaea,0x5a2339,0xecf0ef,0x181816,0xffffff,0x211f1a,0xa360e3,0x8a4f67,0xec75a3,0xec75a5,0xfb7fb1,
0xfefefe,0xfefefe,0xfdfdfd,0xeaeaea,0xebebeb,0xeeeeee,0xeeeeee,0xfdfffd,0xae69e5,0xb163f6,0x471d37,0x894f6a,0x9b6079,0xee75a5,0xfa82b2,
0xfefefe,0xfdfdfd,0xfdfdfd,0xeaeaea,0xe9e9e9,0xefefef,0x1d1d1b,0xad6aea,0xfb83b1,0xf784b5,0xee75a6,0x800304,0xe972a2,0xee72a4,0xfc7eb1,
0xefefef,0xeeeeee,0xeeeeee,0xdcdcdc,0xdcdcdc,0x585858,0x8f58c1,0x4c1a3c,0xeb78a7,0xd27c97,0x830202,0x4e1317,0xde6b9b,0xe06a99,0xee76a6,
0xececec,0xececec,0xececec,0xd8d8d8,0xd9d9d9,0x9b9c9b,0x201319,0x201819,0x4e0d07,0x521014,0x623646,0xb76284,0xe06997,0xde6898,0xec75a5,
0xe9e9e9,0xe9e9e9,0xe9e9e9,0xd7d7d7,0x979596,0xe06c9b,0x9c5270,0xe774a2,0xea75a6,0xe975a4,0xcf6d95,0xd86e98,0xde6797,0xdc6696,0xeb74a4,
0xeaeaea,0xeaeaea,0xebebeb,0xb7b1b5,0xdc6998,0xe06b9b,0xe16b99,0xec73a4,0xec75a5,0xed73a4,0xe46a9b,0xdf6999,0xde6898,0xe06697,0xee73a4,
0xfefefe,0xfcfcfc,0xfdfafb,0xdd769e,0xe575a3,0xf076a7,0xed77a8,0xf981b1,0xfb80b2,0xfb7eb0,0xf074a6,0xed75a5,0xec74a4,0xec74a4,0xf981b1,
0xfefefe,0xfdfdfd,0x271219,0xee72a4,0xed73a4,0xf078a8,0xf077a9,0xfa81b2,0xfd7fb2,0x890104,0xf177a8,0xee76a6,0xeb74a4,0xee74a5,0xfc80b2
};

const long Noot[] PROGMEM =
{
0x1f1f37,0x202039,0x22223a,0x22223b,0x242340,0x0f1016,0x0e0f10,0x0f1014,0x101112,0x101112,0x101112,0x0f0f13,0x22223a,0x21213a,0x21213a,
0x2b2c4c,0x2b2e4f,0x2c2c52,0x101113,0x111214,0x111214,0x111214,0x111214,0x111214,0x111214,0x111214,0x111214,0x111214,0x0b0d10,0x2d2d4f,
0x333159,0x34335b,0x020203,0x0f1012,0x111214,0x111214,0x111214,0x111214,0x111214,0x111214,0x111214,0x111214,0x0c0e0d,0x000000,0x020002,
0x363861,0x000000,0x000000,0x040404,0x0f1110,0x101211,0x0d0f0e,0x0d0f0e,0x0d0f0e,0x0e100f,0x0e100f,0x000000,0x000000,0x000000,0x000000,
0x090812,0x020202,0x9ca7a9,0x9fa9ab,0x010101,0x080808,0x090909,0x060707,0x080808,0x080808,0x060606,0x010101,0xa1acae,0x9faaac,0x010101,
0x000002,0xa2a9ac,0x3a3d40,0x000000,0x353738,0x000000,0x010101,0x000000,0x000000,0x000000,0x000000,0x424445,0x060608,0x353a3e,0x393d3f,
0x000000,0x585c5e,0x050505,0x17191a,0x030405,0x000000,0x000000,0x020203,0x010001,0x010100,0x000000,0x2a2c2d,0x010101,0x020202,0x030304,
0x020202,0x767b7c,0xe0ecec,0x878c8f,0x020101,0x664541,0x603e35,0x765d58,0x745751,0x623b34,0x000100,0x000000,0xd8e1e5,0xb8c0c2,0xa8b0b2,
0x101010,0x2a2e31,0x272b2e,0x101515,0x623f39,0x623f39,0x6f4e4b,0x76615e,0x63403a,0x63403a,0x623f39,0x070a0b,0x121214,0x151618,0x191a1c,
0x1c1d1f,0x393e42,0x3a3f43,0x653f37,0x64413b,0x65423c,0x775f5f,0x796463,0x664442,0x664540,0x65423c,0x221d1b,0x3a3e47,0x383d41,0x393c41,
0x0f1012,0x373c42,0x383f45,0x6b4a41,0x975d53,0xc87c72,0xc87d72,0xc97e74,0xce7d73,0x935550,0xbc726b,0x324043,0x384148,0x3a4147,0x383d43,
0x0d0f10,0x2f3439,0x353e44,0x36404a,0x39404e,0x384151,0x3b4554,0x394353,0x394253,0x364252,0x38424d,0x37414b,0x364049,0x374048,0x30383d,
0x3f4a77,0x14171c,0x2e373e,0x34404c,0x34404c,0x36424e,0x354350,0x354352,0x364353,0x374552,0x374552,0x394553,0x37434f,0x313a43,0x1b2024,
0x3a466e,0x3b4872,0x121415,0x303943,0x364655,0x354555,0x334352,0x334352,0x354554,0x374756,0x354554,0x374554,0x303844,0x16171c,0x050910,
0x354265,0x364268,0x38446c,0x394471,0x13191d,0x2c3846,0x313f4f,0x324050,0x32404f,0x334050,0x323d46,0x1c2128,0x060709,0x2d3555,0x374369,
0x2f3c5c,0x313e60,0x334063,0x324164,0x000000,0x000000,0x040301,0x07090b,0x18212c,0x27313e,0x202834,0x10171d,0x06070a,0x000000,0x010101
};

const long NPC[] PROGMEM =
{
0x88f3fd,0x88f3fd,0x88f3fd,0x88f3fd,0x88f3fd,0x88f3fd,0x88f3fd,0x88f3fd,0x88f3fd,0x88f3fd,0x88f3fd,0x88f3fd,0x88f3fd,0x88f3fd,0x88f3fd,
0x88f3fd,0x88f3fd,0x88f3fd,0x88f3fd,0x43777b,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0x3e3e3e,0x88f3fd,0x88f3fd,0x88f3fd,0x88f3fd,0x88f3fd,
0x88f3fd,0x88f3fd,0x88f3fd,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0x72cacf,0x88f3fd,0x88f3fd,0x88f3fd,
0x88f3fd,0x88f3fd,0xaaaaaa,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0x335b5d,0x88f3fd,0x88f3fd,
0x88f3fd,0x88f3fd,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0x88f3fd,0x88f3fd,
0x88f3fd,0x87f2fc,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0x88f3fd,0x88f3fd,
0x88f3fd,0x223d3f,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0x020202,0x88f3fd,
0x88f3fd,0x142425,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa9a9a9,0x88f3fd,
0x88f3fd,0x8cf7fc,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0x000000,0xa6a6a6,0xa6a6a6,0x9d9d9d,0xa9a9a9,0x393939,0x424242,0x88f3fd,
0x88f3fd,0x88f3fd,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0x343434,0xa6a6a6,0xa6a6a6,0xa6a6a6,0x88f3fd,
0x88f3fd,0x88f3fd,0x20383a,0xa6a6a6,0x727272,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0x88f3fd,
0x88f3fd,0x88f3fd,0x88f3fd,0xa6a6a6,0x666666,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0x121212,0xa6a6a6,0x3d3d3d,0x88f3fd,
0x88f3fd,0x88f3fd,0x88f3fd,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0x88f3fd,0x88f3fd,
0x88f3fd,0x88f3fd,0x88f3fd,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa5a5a5,0xa6a6a6,0x010101,0x010101,0x010101,0x010101,0x606060,0x88f3fd,0x88f3fd,
0x88f3fd,0x88f3fd,0x88f2f8,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0x959595,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0x88f3fd,0x88f3fd,0x88f3fd,
0x88f3fd,0x88f3fd,0xa5a5a5,0xa6a6a6,0x303030,0xa6a6a6,0xa6a6a6,0xa6a6a6,0xa6a6a6,0x000000,0x010101,0x88f3fd,0x88f3fd,0x88f3fd,0x88f3fd
};

void setup() {
//    Serial.begin(115200);
    // XY Matrix
    FastLED.addLeds<CHIPSET, DATA_PIN, COLOR_ORDER>(leds, NUM_LEDS).setCorrection(TypicalSMD5050);
    FastLED.setBrightness(BRIGHTNESS);
    FastLED.clear();
    StartFlash();
}

void loop() {
    // StartFlash();

    DrawOneFrame(Noot);
    FastLED.show();
    delay(BLINK_TIME*100);

    DrawOneFrame(NPC);
    FastLED.show();
    delay(BLINK_TIME*100);

    DrawOneFrame(Doge);
    FastLED.show();
    delay(BLINK_TIME*100);
}

void StartFlash() {
    for (int i=0; i<NUM_LEDS; i++) {
      leds[i] = 0xffffff;
    }
    FastLED.show();
    delay(BLINK_TIME);
    for (int i=0; i<NUM_LEDS; i++) {
      leds[i] = 0xff0000;
    }
    FastLED.show();
    delay(BLINK_TIME);
    for (int i=0; i<NUM_LEDS; i++) {
      leds[i] = 0x00ff00;
    }
    FastLED.show();
    delay(BLINK_TIME);
    for (int i=0; i<NUM_LEDS; i++) {
      leds[i] = 0x0000ff;
    }
    FastLED.show();
    delay(BLINK_TIME);
    for (int i=0; i<NUM_LEDS; i++) {
      leds[i] = 0x00ffff;
    }
    FastLED.show();
    delay(BLINK_TIME);
    for (int i=0; i<NUM_LEDS; i++) {
      leds[i] = 0xff00ff;
    }
    FastLED.show();
    delay(BLINK_TIME);
    for (int i=0; i<NUM_LEDS; i++) {
      leds[i] = 0xffff00;
    }
    FastLED.show();
    delay(BLINK_TIME);
}

void SetWhite()
{
  for (int i=0; i<NUM_LEDS; i++) {
    leds[i] = 0xffffff;
  }
}

void DrawOneFrame(const long pixel_arr[])
{
  for(int y=0; y<LENGTH; y++) {
    for(int x=0; x<WIDTH; x++) {
      if (x==0 && y==0) {
//        Serial.println(pgm_read_dword(&(pixel_arr[x+x*y])), HEX);
      }
      leds[XY(x,y)] = pgm_read_dword(&pixel_arr[x+x*y]);
//      leds[XY(x,y)]  = pixel_arr[x+(x*y)];
    }
  }
//  for (int i=0; i<NUM_LEDS; i++) {
//    leds[i] = pgm_read_dword(&(pixel_arr[i]));
//  }
}
